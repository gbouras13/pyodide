<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>phold_plots — Pyodide </title>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 1100px;
      margin: 1.75rem auto;
      padding: 0 1rem;
      line-height: 1.45;
    }
    fieldset { margin: .5rem 0 1rem; padding: .75rem; border-radius:6px; }
    label { display:block; margin: .35rem 0 .15rem; font-weight:600; }
    input[type="text"], input[type="number"], select {
      width: 320px; padding: .35rem; border-radius:4px; border:1px solid #ccc;
    }
    input[type="file"] { margin-top: .25rem; }
    .inline { display:inline-block; margin-right:1rem; vertical-align:middle; }
    button { margin-top: .75rem; padding: 0.5rem 1rem; font-size: 1rem; cursor: pointer; }
    pre { background: #f5f5f5; padding: 0.75rem; overflow-x:auto; white-space:pre-wrap; }
    .status { font-size:0.95rem; color:#333; margin-top:.5rem; }
    .images { display:flex; flex-wrap:wrap; gap:1rem; margin-top:1rem; }
    .img-card { border:1px solid #ddd; padding:.5rem; border-radius:6px; width:360px;}
    .img-card img { max-width:100%; height:auto; display:block; }
    .small { font-size:0.9rem; color:#444; }
  </style>
</head>
<body>
  <h1>Phold Plot WebAssembly App</h1>

  <p>
    Upload a GenBank (.gbk) file from Phold, tweak your options and click <strong>Run</strong>.<br> This will run <strong>phold plot</strong>.<br>
    Please see phold's documentation for more details about the parameters at <a href="https://phold.readthedocs.io/en/latest/run/" target="_blank">GitHub</a>.<br>
    You can also try the Example button for a pre-loaded example phage.<br>
    
    <strong>phold plot</strong> is run client-side using Wasm (WebAssembly) with Pyodide (Biopython + pyCirclize + matplotlib): no data leaves your machine.<br>
    If you encounter any problems, please leave an issue on <a href="https://github.com/gbouras13/phold-plot-wasm-app" target="_blank">GitHub</a>.<br>
  </p>

  <fieldset>
    <legend><strong>Input</strong></legend>
    <label for="fileInput">GenBank file (.gbk, .gb)</label>
    <input id="fileInput" type="file" accept=".gbk,.gb,.genbank,.gbf,.txt,.fasta" />
    <div class="small">If your file contains multiple contigs, checking <em>Plot every contig</em> will create one plot per contig.</div>
  </fieldset>

  <fieldset>
    <legend><strong>Plot options</strong></legend>

    <div class="inline">
      <label for="prefix">Prefix</label>
      <input id="prefix" type="text" value="phold" />
    </div>

    <div style="margin-top:.5rem">
      <label class="inline"><input id="allContigs" type="checkbox" /> Plot every contig</label>
      <label class="inline"><input id="labelHyp" type="checkbox" /> Label hypothetical proteins</label>
      <label class="inline"><input id="removeOther" type="checkbox" /> Remove tRNA/tmRNA/CRISPR labels</label>
    </div>

    <div style="margin-top:.5rem">
      <label for="plotTitle">Plot title (optional)</label>
      <input id="plotTitle" type="text" placeholder="(defaults to contig id)" />
    </div>

    <div style="margin-top:.5rem">
      <label for="titleSize">Title size</label>
      <input id="titleSize" type="number" value="20" min="6" />
      <label style="margin-left:1rem">Label size</label>
      <input id="labelSize" type="number" value="6.5" min="4" />
    </div>

    <div style="margin-top:.5rem">
      <label for="interval">Axis tick interval (bp)</label>
      <input id="interval" type="number" value="5000" />
      <label style="margin-left:1rem">Truncate long labels to maximum this many characters</label>
      <input id="truncate" type="number" value="20" />
    </div>

    <div style="margin-top:.5rem">
      <label for="dpi">DPI (image quality)</label>
      <input id="dpi" type="number" value="600" />
      <label style="margin-left:1rem">Annotations proportion (0-1)</label>
      <input id="annotations" type="number" min="0" max="1" step="0.05" value="1" />
    </div>

    <div style="margin-top:.5rem">
      <label for="labelIds">Label IDs (optional, newline-separated)</label>
      <textarea id="labelIds" rows="3" style="width:640px; font-family:monospace;" placeholder="Optional list of CDS IDs to always label (one per line)"></textarea>
    </div>

    <!-- NEW: output format selection -->
    <div style="margin-top:.5rem">
      <label><strong>Output format</strong></label>
      <label class="inline">
        <input id="fmtPng" type="checkbox" checked /> PNG (.png)
      </label>
      <label class="inline" style="margin-left:1rem;">
        <input id="fmtSvg" type="checkbox" /> SVG (.svg)
      </label>
      <div class="small">Choose one or both. If both are selected you'll get PNG + SVG.</div>
    </div>

  </fieldset>

  <div>
    <button id="runBtn">Run</button>
    <button id="exampleBtn">Example</button>
    <button id="clearBtn">Clear results</button>
  </div>

  <div class="status" id="status">Pyodide will be loaded on demand when you click <strong>Run</strong>.</div>

  <h2>Logs</h2>
  <pre id="log" style="height:160px; overflow:auto;">(logs will appear here)</pre>

  <h2>Plots</h2>
  <div id="images" class="images"></div>

  <script type="text/javascript">
    let pyodideReadyPromise = null;
    const runBtn = document.getElementById("runBtn");
    const exampleBtn = document.getElementById("exampleBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");
    const imagesEl = document.getElementById("images");
    const fileInput = document.getElementById("fileInput");

    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function ensurePyodide() {
      if (!pyodideReadyPromise) {
        statusEl.textContent = "Loading Pyodide… (this downloads ~ a few MB)";
        pyodideReadyPromise = loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/" });
      }
      return pyodideReadyPromise;
    }

    async function installDependencies(pyodide) {
      statusEl.textContent = "Installing micropip + Biopython + pycirclize (may take 10–60s)...";
      log("Installing micropip and packages. This can take a while on first run.");
      await pyodide.loadPackage("micropip");
      const micropip = pyodide.pyimport("micropip");
      const packages = ["biopython", "pycirclize"];
      for (const pkg of packages) {
        log(`Installing ${pkg} ...`);
        try {
          await micropip.install(pkg);
          log(`Installed ${pkg}`);
        } catch (err) {
          log(`Error installing ${pkg}: ${err}`);
        }
      }
      statusEl.textContent = "Dependencies installed (or attempted).";
      log("Package installation step complete.");
    }

    async function runPhold(gbkText) {
      runBtn.disabled = true;
      exampleBtn.disabled = true;
      clearBtn.disabled = true;
      imagesEl.innerHTML = "";
      logEl.textContent = "";

      const opts = {
        prefix: document.getElementById("prefix").value || "phold",
        outputDir: "phold_plots",
        allContigs: document.getElementById("allContigs").checked,
        labelHyp: document.getElementById("labelHyp").checked,
        removeOther: document.getElementById("removeOther").checked,
        plotTitle: document.getElementById("plotTitle").value || null,
        titleSize: Number(document.getElementById("titleSize").value) || 20,
        labelSize: Number(document.getElementById("labelSize").value) || 6.5,
        interval: Number(document.getElementById("interval").value) || 5000,
        truncate: Number(document.getElementById("truncate").value) || 20,
        dpi: Number(document.getElementById("dpi").value) || 600,
        annotations: Number(document.getElementById("annotations").value) || 1.0,
        labelIds: (document.getElementById("labelIds").value || "")
          .split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean),
        fmtPng: document.getElementById("fmtPng").checked,
        fmtSvg: document.getElementById("fmtSvg").checked
      };

      const pyodide = await ensurePyodide();
      await installDependencies(pyodide);

      statusEl.textContent = "Running plotting in Pyodide (this may take a while)...";
      log("Starting Python plotting...");

      try {
        pyodide.globals.set("uploaded_text_js", gbkText);
        pyodide.globals.set("opts_js", opts);

        const result = await pyodide.runPythonAsync(`
    # --- Python (runs inside Pyodide) ---
    import os
    from pathlib import Path
    from io import BytesIO
    import json

    opts = opts_js.to_py()

    # write uploaded GBK
    tmp_dir = Path("/tmp/pyodide_phold")
    tmp_dir.mkdir(parents=True, exist_ok=True)
    gbk_path = tmp_dir / "upload.gbk"
    with open(gbk_path, "w", encoding="utf-8") as fh:
        fh.write(uploaded_text_js)

    # imports
    import numpy as np
    import matplotlib
    from matplotlib.patches import Patch
    from matplotlib.lines import Line2D
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    from Bio import SeqIO
    from Bio.Seq import Seq
    from Bio.SeqFeature import SeqFeature
    from pycirclize import Circos

    # parse records with Biopython (robust across pyodide Biopython)
    records = list(SeqIO.parse(str(gbk_path), "genbank"))
    if len(records) == 0:
        raise RuntimeError("No GenBank records found in uploaded file.")

    # Build lookups
    rec_by_id = {rec.id: rec for rec in records}
    # fallback: also map by name and by locus_tag if available
    for rec in records:
        if rec.name not in rec_by_id:
            rec_by_id.setdefault(rec.name, rec)

    seqid2size = {rid: len(rec.seq) for rid, rec in rec_by_id.items()}
    seqids = list(seqid2size.keys())

    # simple gc and gc-skew calculators using sliding window
    def sliding_gc(seq, window=100):
        s = str(seq).upper()
        n = len(s)
        if n == 0:
            return [], np.array([])
        half = window // 2
        positions = []
        values = []
        # pad sequence edges by repeating ends for consistent windowing
        padded = s
        for i in range(n):
            start = max(0, i - half)
            end = min(n, i + half)
            subseq = padded[start:end]
            gc = subseq.count("G") + subseq.count("C")
            if len(subseq) > 0:
                values.append((gc / len(subseq)) * 100.0)
                positions.append(i + 1)  # 1-based coordinate
        return positions, np.array(values)

    def sliding_gc_skew(seq, window=100):
        s = str(seq).upper()
        n = len(s)
        if n == 0:
            return [], np.array([])
        half = window // 2
        positions = []
        values = []
        for i in range(n):
            start = max(0, i - half)
            end = min(n, i + half)
            subseq = s[start:end]
            g = subseq.count("G")
            c = subseq.count("C")
            denom = g + c
            skew = (g - c) / denom if denom > 0 else 0.0
            values.append(skew)
            positions.append(i + 1)
        return positions, np.array(values)

    # create and return png/svg bytes for each plotted contig
    def create_one_plot(contig_id):
        seq_len = seqid2size[contig_id]
        circos = Circos(sectors={contig_id: seq_len})
        title_to_use = opts.get("plotTitle") or contig_id
        circos.text(title_to_use, size=int(opts.get("titleSize",20)), r=215)
        sector = circos.get_sector(contig_id)
        cds_track = sector.add_track((70,80))
        cds_track.axis(fc="#EEEEEE", ec="none")

        # get features from Biopython record
        rec = rec_by_id[contig_id]
        features = rec.features

        fwd = [f for f in features if getattr(f.location, "strand", 1) == 1]
        rev = [f for f in features if getattr(f.location, "strand", 1) == -1]
        cds_features = [f for f in features if f.type == "CDS"]
        trna_features = [f for f in features if f.type == "tRNA"]
        tmrna_features = [f for f in features if f.type in ("tmRNA","tm-RNA","tmRNA")]
        crispr_features = [f for f in features if f.type in ("repeat_region","CRISPR")]

        # basic data_dict as before
        data_dict = {
            "acr_defense_vfdb_card": {"col": "#FF0000", "fwd_list": [], "rev_list": []},
            "unk": {"col": "#AAAAAA", "fwd_list": [], "rev_list": []},
            "other": {"col": "#4deeea", "fwd_list": [], "rev_list": []},
            "tail": {"col": "#74ee15", "fwd_list": [], "rev_list": []},
            "transcription": {"col": "#ffe700", "fwd_list": [], "rev_list": []},
            "dna": {"col": "#f000ff", "fwd_list": [], "rev_list": []},
            "lysis": {"col": "#001eff", "fwd_list": [], "rev_list": []},
            "moron": {"col": "#8900ff", "fwd_list": [], "rev_list": []},
            "int": {"col": "#E0B0FF", "fwd_list": [], "rev_list": []},
            "head": {"col": "#ff008d", "fwd_list": [], "rev_list": []},
            "con": {"col": "#5A5A5A", "fwd_list": [], "rev_list": []},
        }

        def qval(feat, key, idx=0):
            try:
                return feat.qualifiers.get(key, [""])[idx]
            except Exception:
                return ""

        for feat in fwd:
            if feat.type == "CDS":
                phrog = qval(feat, "phrog")
                func = qval(feat, "function")
                if any(x in phrog for x in ("vfdb","card","acr","defensefinder")):
                    data_dict["acr_defense_vfdb_card"]["fwd_list"].append(feat)
                else:
                    if func.startswith("unknown") or func == "":
                        data_dict["unk"]["fwd_list"].append(feat)
                    elif "tail" in func:
                        data_dict["tail"]["fwd_list"].append(feat)
                    elif "transcription" in func:
                        data_dict["transcription"]["fwd_list"].append(feat)
                    elif "DNA" in func:
                        data_dict["dna"]["fwd_list"].append(feat)
                    elif "lysis" in func:
                        data_dict["lysis"]["fwd_list"].append(feat)
                    elif "moron" in func:
                        data_dict["moron"]["fwd_list"].append(feat)
                    elif "integration" in func:
                        data_dict["int"]["fwd_list"].append(feat)
                    elif "head" in func:
                        data_dict["head"]["fwd_list"].append(feat)
                    else:
                        data_dict["other"]["fwd_list"].append(feat)

        for feat in rev:
            if feat.type == "CDS":
                phrog = qval(feat, "phrog")
                func = qval(feat, "function")
                if any(x in phrog for x in ("vfdb","card","acr","defensefinder")):
                    data_dict["acr_defense_vfdb_card"]["rev_list"].append(feat)
                else:
                    if func.startswith("unknown") or func == "":
                        data_dict["unk"]["rev_list"].append(feat)
                    elif "tail" in func:
                        data_dict["tail"]["rev_list"].append(feat)
                    elif "transcription" in func:
                        data_dict["transcription"]["rev_list"].append(feat)
                    elif "DNA" in func:
                        data_dict["dna"]["rev_list"].append(feat)
                    elif "lysis" in func:
                        data_dict["lysis"]["rev_list"].append(feat)
                    elif "moron" in func:
                        data_dict["moron"]["rev_list"].append(feat)
                    elif "integration" in func:
                        data_dict["int"]["rev_list"].append(feat)
                    elif "head" in func:
                        data_dict["head"]["rev_list"].append(feat)
                    else:
                        data_dict["other"]["rev_list"].append(feat)

        # add the tracks now
        for key in data_dict.keys():
            cds_track.genomic_features(data_dict[key]["fwd_list"], plotstyle="arrow", r_lim=(75,80), fc=data_dict[key]["col"])
            cds_track.genomic_features(data_dict[key]["rev_list"], plotstyle="arrow", r_lim=(70,75), fc=data_dict[key]["col"])

        # extras
        extras_col = "black"
        fwd_ex = [f for f in fwd if f.type in ("tRNA","tmRNA")]
        rev_ex = [f for f in rev if f.type in ("tRNA","tmRNA")]
        cds_track.genomic_features(fwd_ex, plotstyle="arrow", r_lim=(75,80), fc=extras_col)
        cds_track.genomic_features(rev_ex, plotstyle="arrow", r_lim=(70,75), fc=extras_col)

        # prepare CDS labels
        pos_list = []
        labels = []
        length_list = []
        id_list = []
        label_force_list = set(opts.get("labelIds") or [])

        for f in cds_features:
            try:
                start = int(f.location.start)
                end = int(f.location.end)
            except Exception:
                continue
            pos = (start + end) / 2.0
            length = max(1, end - start)
            product = qval(f, "product")
            fid = qval(f, "ID") or qval(f, "protein_id") or qval(f, "locus_tag") or ""
            label = product or ""
            # apply hypothetical rules
            if fid in label_force_list or opts.get("labelHyp"):
                if len(label) > opts.get("truncate",20):
                    label = label[:opts.get("truncate",20)] + "..."
                pos_list.append(pos); labels.append(label); length_list.append(length); id_list.append(fid)
            else:
                if label == "" or label.lower().startswith("hypothetical") or label.lower().startswith("unknown"):
                    continue
                if len(label) > opts.get("truncate",20):
                    label = label[:opts.get("truncate",20)] + "..."
                pos_list.append(pos); labels.append(label); length_list.append(length); id_list.append(fid)

        # thin annotations by 'annotations' proportion
        ann_prop = float(opts.get("annotations",1.0))
        if ann_prop <= 0:
            pos_list = []; labels = []
        elif ann_prop < 1.0 and len(length_list) > 0:
            k = max(1, int(len(length_list) * ann_prop))
            idx_sorted = sorted(range(len(length_list)), key=lambda i: -length_list[i])[:k]
            idx_sorted.sort()
            pos_list = [pos_list[i] for i in idx_sorted]
            labels = [labels[i] for i in idx_sorted]

        # xticks by interval
        cds_track.xticks_by_interval(interval=int(opts.get("interval",5000)), outer=False, show_bottom_line=False, label_formatter=lambda v: f"{v/1000:.0f} Kb", label_orientation="vertical", line_kws=dict(ec="grey"), label_size=int(opts.get("labelSize",6.5)))

        # Plot CDS product labels on outer position
        cds_track.xticks(
            pos_list,
            labels,
            label_orientation="vertical",
            show_bottom_line=True,
            label_size=int(opts.get("labelSize",8)),
            line_kws=dict(ec="grey") 
        )

        # compute GC content & skew with sliding windows
        contig_seq = rec.seq
        pos_gc, gc_vals = sliding_gc(contig_seq, window=10)
        # normalize gc to percent difference from mean
        mean_gc = np.mean(gc_vals) if len(gc_vals)>0 else 0.0
        gc_vals_rel = gc_vals - mean_gc
        pos_gc = list(pos_gc)
        positive_gc = np.where(gc_vals_rel > 0, gc_vals_rel, 0)
        negative_gc = np.where(gc_vals_rel < 0, gc_vals_rel, 0)
        gc_track = sector.add_track((42.5, 60))
        abs_max_gc = np.max(np.abs(gc_vals_rel)) if len(gc_vals_rel)>0 else 1
        gc_track.fill_between(pos_gc, positive_gc, 0, vmin=-abs_max_gc, vmax=abs_max_gc, color="black")
        gc_track.fill_between(pos_gc, negative_gc, 0, vmin=-abs_max_gc, vmax=abs_max_gc, color="grey")

        pos_skew, skew_vals = sliding_gc_skew(contig_seq, window=10)
        pos_skew = list(pos_skew)
        positive_skew = np.where(skew_vals>0, skew_vals, 0)
        negative_skew = np.where(skew_vals<0, skew_vals, 0)
        abs_max_skew = np.max(np.abs(skew_vals)) if len(skew_vals)>0 else 1
        skew_track = sector.add_track((25, 42.5))
        skew_track.fill_between(pos_skew, positive_skew, 0, vmin=-abs_max_skew, vmax=abs_max_skew, color="green")
        skew_track.fill_between(pos_skew, negative_skew, 0, vmin=-abs_max_skew, vmax=abs_max_skew, color="purple")

        ################################
        # PHROG legend
        ################################

        handle_phrogs = [
            Patch(color=data_dict["unk"]["col"], label="Unknown Function"),
            Patch(color=data_dict["other"]["col"], label="Other Function"),
            Patch(color=data_dict["transcription"]["col"], label="Transcription Regulation"),
            Patch(color=data_dict["dna"]["col"], label="DNA/RNA & nucleotide metabolism"),
            Patch(color=data_dict["lysis"]["col"], label="Lysis"),
            Patch(color=data_dict["moron"]["col"],
                  label="Moron / AMG / host takeover"),
            Patch(color=data_dict["int"]["col"], label="Integration & excision"),
            Patch(color=data_dict["head"]["col"], label="Head & packaging"),
            Patch(color=data_dict["con"]["col"], label="Connector"),
            Patch(color=data_dict["tail"]["col"], label="Tail"),
            Patch(color=data_dict["acr_defense_vfdb_card"]["col"],
                  label="VF / AMR / ACR / DF"),
        ]

        fig = circos.plotfig()

        # Position above the plot (works well in Pyodide)
        phrog_legend = circos.ax.legend(
            handles=handle_phrogs,
            title="PHROG CDS",
            fontsize=7,
            title_fontsize=8,
            handlelength=1.3,
            frameon=False,
            bbox_to_anchor=(-0.08, 1.49),
            loc="upper left",
        )
        
        # Set the legend title to left alignment
        phrog_legend.get_title().set_ha("left")

        circos.ax.add_artist(phrog_legend)

        ################################
        # GC content / GC skew legend
        ################################

        handle_gc_content = [
            Line2D([], [], color="black", label="Positive GC Content",
                  marker="^", ms=6, ls="None"),
            Line2D([], [], color="grey", label="Negative GC Content",
                  marker="v", ms=6, ls="None"),
        ]

        handle_gc_skew = [
            Line2D([], [], color="green", label="Positive GC Skew",
                  marker="^", ms=6, ls="None"),
            Line2D([], [], color="purple", label="Negative GC Skew",
                  marker="v", ms=6, ls="None"),
        ]

        handle_other_features = [
            Patch(color=extras_col, label="tRNA / tmRNA / CRISPR")
        ]

        # Combine all handles into one small legend
        combined_handles = (
            handle_gc_content +
            handle_gc_skew +
            handle_other_features
        )

        gc_legend = circos.ax.legend(
            handles=combined_handles,
            title="Other Features",
            fontsize=7,
            title_fontsize=8,
            handlelength=1.2,
            frameon=False,
            bbox_to_anchor=(0.73, 1.49),
            loc="upper left",
        )

        circos.ax.add_artist(gc_legend)

        out_dir = tmp_dir / opts.get("outputDir","phold_plots")
        out_dir.mkdir(parents=True, exist_ok=True)
        png_path = out_dir / f"{opts.get('prefix','phold')}_{contig_id}.png"
        svg_path = out_dir / f"{opts.get('prefix','phold')}_{contig_id}.svg"
        dpi = int(opts.get("dpi",600))

        # Save only the requested formats (but saving both still safe if both requested).
        if opts.get("fmtPng", True):
            fig.savefig(str(png_path), dpi=dpi)
        if opts.get("fmtSvg", False):
            fig.savefig(str(svg_path), format="svg", dpi=dpi)

        plt.close(fig)

        out_map = {}
        if opts.get("fmtPng", True) and png_path.exists():
            with open(png_path, "rb") as f:
                out_map[str(png_path)] = f.read()
        if opts.get("fmtSvg", False) and svg_path.exists():
            with open(svg_path, "rb") as f:
                out_map[str(svg_path)] = f.read()

        return out_map

    # decide contigs
    to_plot = seqids if opts.get("allContigs") else seqids[:1]

    # collect bytes
    out = {}
    for contig in to_plot:
        contig_out_map = create_one_plot(contig)
        # contig_out_map is a dict mapping filepath -> bytes for requested formats
        for k,v in contig_out_map.items():
            out[k] = v

    out
        `);
       const pyRet = result.toJs ? result.toJs() : result;
        // pyRet is an object mapping filenames -> byte arrays
        for (const [fname, pyBytes] of Object.entries(pyRet)) {
          const arr = pyBytes instanceof Uint8Array ? pyBytes : new Uint8Array(pyBytes);
          const blobType = fname.endsWith(".svg") ? "image/svg+xml" : "image/png";
          const blob = new Blob([arr], { type: blobType });
          const url = URL.createObjectURL(blob);

          const card = document.createElement("div");
          card.className = "img-card";
          const title = document.createElement("div");
          title.innerHTML = `<strong>${fname.split("/").pop()}</strong>`;
          const img = document.createElement("img");
          img.src = url;
          const dlLink = document.createElement("a");
          dlLink.href = url;
          dlLink.download = fname.split("/").pop();
          dlLink.textContent = "Download";
          dlLink.style.display = "inline-block";
          dlLink.style.marginTop = ".5rem";
          card.appendChild(title);
          card.appendChild(img);
          card.appendChild(dlLink);
          imagesEl.appendChild(card);
        }

        statusEl.textContent = "Done. Images displayed below.";
        log("Plotting finished and images loaded.");
      } catch (err) {
        console.error(err);
        log("Error running Python: " + String(err));
        statusEl.textContent = "Error (see logs)";
      } finally {
        runBtn.disabled = false;
        clearBtn.disabled = false;
      }
    }


    exampleBtn.addEventListener("click", async () => {
      statusEl.textContent = "Loading example GBK from data/NC_043029_phold_output.gbk...";
      try {
        const resp = await fetch("data/NC_043029_phold_output.gbk");
        const text = await resp.text();
        await runPhold(text);
      } catch (err) {
        log("Error loading example file: " + err);
        statusEl.textContent = "Error loading example GBK";
      }
    });

    runBtn.addEventListener("click", async () => {
      const file = fileInput.files[0];
      if (!file) {
        alert("Please select a GenBank file first.");
        return;
      }
      const text = await file.text();
      await runPhold(text);
    });

    clearBtn.addEventListener("click", () => {
      imagesEl.innerHTML = "";
      logEl.textContent = "";
      statusEl.textContent = "Cleared.";
    });

  </script>
</body>
</html>
